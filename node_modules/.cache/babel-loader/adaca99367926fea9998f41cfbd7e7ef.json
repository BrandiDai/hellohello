{"ast":null,"code":"import ExponentAV from './ExponentAV';\nexport * from './Audio/Recording';\nexport * from './Audio/Sound';\nexport { setIsEnabledAsync } from './Audio/AudioAvailability';\nexport { PitchCorrectionQuality } from './AV';\nexport const INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = 0;\nexport const INTERRUPTION_MODE_IOS_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_IOS_DUCK_OTHERS = 2;\nexport const INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = 2; // Returns true if value is in validValues, and false if not.\n\nconst _isValueValid = (value, validValues) => {\n  return validValues.filter(validValue => validValue === value).length > 0;\n}; // Returns array of missing keys in object. Returns an empty array if no missing keys are found.\n\n\nconst _populateMissingKeys = (userAudioMode, defaultAudioMode) => {\n  for (let key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n\n  return userAudioMode;\n};\n\nconst defaultMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: true\n};\nlet currentAudioMode = null;\n\nfunction getCurrentAudioMode() {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n\n  return currentAudioMode;\n}\n\nexport async function setAudioModeAsync(mode) {\n  mode = _populateMissingKeys(mode, getCurrentAudioMode());\n  currentAudioMode = mode;\n\n  if (!_isValueValid(mode.interruptionModeIOS, [INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS, INTERRUPTION_MODE_IOS_DO_NOT_MIX, INTERRUPTION_MODE_IOS_DUCK_OTHERS])) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n\n  if (!_isValueValid(mode.interruptionModeAndroid, [INTERRUPTION_MODE_ANDROID_DO_NOT_MIX, INTERRUPTION_MODE_ANDROID_DUCK_OTHERS])) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n\n  if (typeof mode.allowsRecordingIOS !== 'boolean' || typeof mode.playsInSilentModeIOS !== 'boolean' || typeof mode.staysActiveInBackground !== 'boolean' || typeof mode.shouldDuckAndroid !== 'boolean' || typeof mode.playThroughEarpieceAndroid !== 'boolean') {\n    throw new Error('\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.');\n  }\n\n  return await ExponentAV.setAudioMode(mode);\n}","map":{"version":3,"sources":["../src/Audio.ts"],"names":[],"mappings":"AAAA,OAAO,UAAP,MAAuB,cAAvB;AAEA,cAAc,mBAAd;AACA,cAAc,eAAd;AACA,SAAS,iBAAT,QAAkC,2BAAlC;AACA,SAAS,sBAAT,QAAuC,MAAvC;AAYA,OAAO,MAAM,qCAAqC,GAAG,CAA9C;AACP,OAAO,MAAM,gCAAgC,GAAG,CAAzC;AACP,OAAO,MAAM,iCAAiC,GAAG,CAA1C;AAEP,OAAO,MAAM,oCAAoC,GAAG,CAA7C;AACP,OAAO,MAAM,qCAAqC,GAAG,CAA9C,C,CAEP;;AACA,MAAM,aAAa,GAAG,CAAC,KAAD,EAAa,WAAb,KAA4C;AAChE,SAAO,WAAW,CAAC,MAAZ,CAAmB,UAAU,IAAI,UAAU,KAAK,KAAhD,EAAuD,MAAvD,GAAgE,CAAvE;AACD,CAFD,C,CAIA;;;AACA,MAAM,oBAAoB,GAAG,CAAC,aAAD,EAAwB,gBAAxB,KAAkE;AAC7F,OAAK,IAAI,GAAT,IAAgB,gBAAhB,EAAkC;AAChC,QAAI,CAAC,aAAa,CAAC,cAAd,CAA6B,GAA7B,CAAL,EAAwC;AACtC,MAAA,aAAa,CAAC,GAAD,CAAb,GAAqB,gBAAgB,CAAC,GAAD,CAArC;AACD;AACF;;AACD,SAAO,aAAP;AACD,CAPD;;AASA,MAAM,WAAW,GAAc;AAC7B,EAAA,kBAAkB,EAAE,KADS;AAE7B,EAAA,mBAAmB,EAAE,qCAFQ;AAG7B,EAAA,oBAAoB,EAAE,KAHO;AAI7B,EAAA,uBAAuB,EAAE,KAJI;AAK7B,EAAA,uBAAuB,EAAE,qCALI;AAM7B,EAAA,iBAAiB,EAAE,IANU;AAO7B,EAAA,0BAA0B,EAAE;AAPC,CAA/B;AAUA,IAAI,gBAAgB,GAAqB,IAAzC;;AAEA,SAAS,mBAAT,GAA4B;AAC1B,MAAI,CAAC,gBAAL,EAAuB;AACrB,WAAO,WAAP;AACD;;AACD,SAAO,gBAAP;AACD;;AAED,OAAO,eAAe,iBAAf,CAAiC,IAAjC,EAAgD;AACrD,EAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,EAAO,mBAAmB,EAA1B,CAA3B;AACA,EAAA,gBAAgB,GAAG,IAAnB;;AAEA,MACE,CAAC,aAAa,CAAC,IAAI,CAAC,mBAAN,EAA2B,CACvC,qCADuC,EAEvC,gCAFuC,EAGvC,iCAHuC,CAA3B,CADhB,EAME;AACA,UAAM,IAAI,KAAJ,CAAU,oDAAV,CAAN;AACD;;AACD,MACE,CAAC,aAAa,CAAC,IAAI,CAAC,uBAAN,EAA+B,CAC3C,oCAD2C,EAE3C,qCAF2C,CAA/B,CADhB,EAKE;AACA,UAAM,IAAI,KAAJ,CAAU,wDAAV,CAAN;AACD;;AACD,MACE,OAAO,IAAI,CAAC,kBAAZ,KAAmC,SAAnC,IACA,OAAO,IAAI,CAAC,oBAAZ,KAAqC,SADrC,IAEA,OAAO,IAAI,CAAC,uBAAZ,KAAwC,SAFxC,IAGA,OAAO,IAAI,CAAC,iBAAZ,KAAkC,SAHlC,IAIA,OAAO,IAAI,CAAC,0BAAZ,KAA2C,SAL7C,EAME;AACA,UAAM,IAAI,KAAJ,CACJ,iJADI,CAAN;AAGD;;AACD,SAAO,MAAM,UAAU,CAAC,YAAX,CAAwB,IAAxB,CAAb;AACD","sourcesContent":["import ExponentAV from './ExponentAV';\n\nexport * from './Audio/Recording';\nexport * from './Audio/Sound';\nexport { setIsEnabledAsync } from './Audio/AudioAvailability';\nexport { PitchCorrectionQuality } from './AV';\n\nexport type AudioMode = {\n  allowsRecordingIOS: boolean;\n  interruptionModeIOS: number;\n  playsInSilentModeIOS: boolean;\n  staysActiveInBackground: boolean;\n  interruptionModeAndroid: number;\n  shouldDuckAndroid: boolean;\n  playThroughEarpieceAndroid: boolean;\n};\n\nexport const INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = 0;\nexport const INTERRUPTION_MODE_IOS_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_IOS_DUCK_OTHERS = 2;\n\nexport const INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = 2;\n\n// Returns true if value is in validValues, and false if not.\nconst _isValueValid = (value: any, validValues: any[]): boolean => {\n  return validValues.filter(validValue => validValue === value).length > 0;\n};\n\n// Returns array of missing keys in object. Returns an empty array if no missing keys are found.\nconst _populateMissingKeys = (userAudioMode: Object, defaultAudioMode: AudioMode): AudioMode => {\n  for (let key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n  return userAudioMode as AudioMode;\n};\n\nconst defaultMode: AudioMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: true,\n};\n\nlet currentAudioMode: AudioMode | null = null;\n\nfunction getCurrentAudioMode(): AudioMode {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n  return currentAudioMode;\n}\n\nexport async function setAudioModeAsync(mode: AudioMode): Promise<void> {\n  mode = _populateMissingKeys(mode, getCurrentAudioMode());\n  currentAudioMode = mode;\n\n  if (\n    !_isValueValid(mode.interruptionModeIOS, [\n      INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS,\n      INTERRUPTION_MODE_IOS_DO_NOT_MIX,\n      INTERRUPTION_MODE_IOS_DUCK_OTHERS,\n    ])\n  ) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (\n    !_isValueValid(mode.interruptionModeAndroid, [\n      INTERRUPTION_MODE_ANDROID_DO_NOT_MIX,\n      INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,\n    ])\n  ) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.staysActiveInBackground !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean' ||\n    typeof mode.playThroughEarpieceAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  return await ExponentAV.setAudioMode(mode);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}