{"ast":null,"code":"import { SyntheticPlatformEmitter } from '@unimodules/core';\n\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n\n  const isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  const status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\n\nfunction setStatusForMedia(media, status) {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  } // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n\n\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nexport default {\n  get name() {\n    return 'ExponentAV';\n  },\n\n  async getStatusForVideo(element) {\n    return getStatusFromMedia(element);\n  },\n\n  async loadForVideo(element, nativeSource, fullInitialStatus) {\n    return getStatusFromMedia(element);\n  },\n\n  async unloadForVideo(element) {\n    return getStatusFromMedia(element);\n  },\n\n  async setStatusForVideo(element, status) {\n    return setStatusForMedia(element, status);\n  },\n\n  async replayVideo(element, status) {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Audio */\n  async setAudioMode() {},\n\n  async setAudioIsEnabled() {},\n\n  async getStatusForSound(element) {\n    return getStatusFromMedia(element);\n  },\n\n  async loadForSound(nativeSource, fullInitialStatus) {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media)\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error.message\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n    return [media, status];\n  },\n\n  async unloadForSound(element) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n\n  async setStatusForSound(element, status) {\n    return setStatusForMedia(element, status);\n  },\n\n  async replaySound(element, status) {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus() {},\n\n  async prepareAudioRecorder() {},\n\n  async startAudioRecording() {},\n\n  async pauseAudioRecording() {},\n\n  async stopAudioRecording() {},\n\n  async unloadAudioRecorder() {}\n\n};","map":{"version":3,"sources":["../src/ExponentAV.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { SyntheticPlatformEmitter } from '@unimodules/core';\n\nimport { PlaybackNativeSource, PlaybackStatus, PlaybackStatusToSet } from './AV';\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): PlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: PlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nfunction setStatusForMedia(media: HTMLMediaElement, status: PlaybackStatusToSet): PlaybackStatus {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<PlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: PlaybackNativeSource,\n    fullInitialStatus: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<PlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: PlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, PlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus() {},\n  async prepareAudioRecorder() {},\n  async startAudioRecording() {},\n  async pauseAudioRecording() {},\n  async stopAudioRecording() {},\n  async unloadAudioRecorder() {},\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}