{"ast":null,"code":"/** @license React v16.12.0\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var ReactDOM = require('react-dom');\n\n    var _assign = require('object-assign'); // Do not require this module directly! Use normal `invariant` calls with\n    // template literal strings. The messages will be replaced with error codes\n    // during build.\n\n    /**\n     * Use invariant() to assert state which your program assumes to be true.\n     *\n     * Provide sprintf-style format (only %s is supported) and arguments\n     * to provide information about what broke and what you were\n     * expecting.\n     *\n     * The invariant message will be stripped in production, but the invariant\n     * will remain to ensure logic does not differ in production.\n     */\n\n\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // unintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n      }\n    }\n    /**\n     * Call a function while guarding against errors that happens within it.\n     * Returns an error if it throws, otherwise null.\n     *\n     * In production, this is implemented using a try-catch. The reason we don't\n     * use a try-catch directly is so that we can swap out a different\n     * implementation in DEV mode.\n     *\n     * @param {String} name of the guard to use for logging or debugging\n     * @param {Function} func The function to invoke\n     * @param {*} context The context to use when calling the function\n     * @param {...*} args Arguments for function\n     */\n\n    /**\n     * Same as invokeGuardedCallback, but instead of returning an error, it stores\n     * it in a global so it can be rethrown by `rethrowCaughtError` later.\n     * TODO: See if caughtError and rethrowError can be unified.\n     *\n     * @param {String} name of the guard to use for logging or debugging\n     * @param {Function} func The function to invoke\n     * @param {*} context The context to use when calling the function\n     * @param {...*} args Arguments for function\n     */\n\n    /**\n     * During execution of guarded functions we will capture the first error which\n     * we will rethrow to be handled by the top level error handler.\n     */\n\n    /**\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n    var warningWithoutStack = function () {};\n\n    {\n      warningWithoutStack = function (condition, format) {\n        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (args.length > 8) {\n          // Check before the condition to catch violations early.\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== 'undefined') {\n          var argsWithFormat = args.map(function (item) {\n            return '' + item;\n          });\n          argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n          // breaks IE9: https://github.com/facebook/react/issues/13610\n\n          Function.prototype.apply.call(console.error, console, argsWithFormat);\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          var argIndex = 0;\n          var message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n          throw new Error(message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n    var getFiberCurrentPropsFromNode$1 = null;\n    var getInstanceFromNode$1 = null;\n    var getNodeFromInstance$1 = null;\n\n    function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n      getFiberCurrentPropsFromNode$1 = getFiberCurrentPropsFromNodeImpl;\n      getInstanceFromNode$1 = getInstanceFromNodeImpl;\n      getNodeFromInstance$1 = getNodeFromInstanceImpl;\n      {\n        !(getNodeFromInstance$1 && getInstanceFromNode$1) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n      }\n    }\n\n    var validateEventDispatches;\n    {\n      validateEventDispatches = function (event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n      };\n    }\n    /**\n     * Dispatch the event to the listener.\n     * @param {SyntheticEvent} event SyntheticEvent to handle\n     * @param {function} listener Application-level callback\n     * @param {*} inst Internal component instance\n     */\n\n    /**\n     * Standard/simple iteration through an event's collected dispatches.\n     */\n\n    /**\n     * Standard/simple iteration through an event's collected dispatches, but stops\n     * at the first dispatch execution returning true, and returns that id.\n     *\n     * @return {?string} id of the first dispatch execution who's listener returns\n     * true, or null if no listener returned true.\n     */\n\n    function executeDispatchesInOrderStopAtTrueImpl(event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n          if (dispatchListeners[i](event, dispatchInstances[i])) {\n            return dispatchInstances[i];\n          }\n        }\n      } else if (dispatchListeners) {\n        if (dispatchListeners(event, dispatchInstances)) {\n          return dispatchInstances;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * @see executeDispatchesInOrderStopAtTrueImpl\n     */\n\n\n    function executeDispatchesInOrderStopAtTrue(event) {\n      var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n      event._dispatchInstances = null;\n      event._dispatchListeners = null;\n      return ret;\n    }\n    /**\n     * Execution of a \"direct\" dispatch - there must be at most one dispatch\n     * accumulated on the event or it is considered an error. It doesn't really make\n     * sense for an event with multiple dispatches (bubbled) to keep track of the\n     * return values at each dispatch execution, but it does tend to make sense when\n     * dealing with \"direct\" dispatches.\n     *\n     * @return {*} The return value of executing the single dispatch.\n     */\n\n\n    function executeDirectDispatch(event) {\n      {\n        validateEventDispatches(event);\n      }\n      var dispatchListener = event._dispatchListeners;\n      var dispatchInstance = event._dispatchInstances;\n\n      if (!!Array.isArray(dispatchListener)) {\n        {\n          throw Error(\"executeDirectDispatch(...): Invalid `event`.\");\n        }\n      }\n\n      event.currentTarget = dispatchListener ? getNodeFromInstance$1(dispatchInstance) : null;\n      var res = dispatchListener ? dispatchListener(event) : null;\n      event.currentTarget = null;\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n      return res;\n    }\n    /**\n     * @param {SyntheticEvent} event\n     * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n     */\n\n\n    function hasDispatches(event) {\n      return !!event._dispatchListeners;\n    } // Before we know whether it is function or class\n    // Root of a host tree. Could be nested inside another node.\n    // A subtree. Could be an entry point to a different renderer.\n\n\n    var HostComponent = 5;\n\n    function getParent(inst) {\n      do {\n        inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n        // That is depending on if we want nested subtrees (layers) to bubble\n        // events to their parent. We could also go through parentNode on the\n        // host node but that wouldn't work for React Native and doesn't let us\n        // do the portal feature.\n      } while (inst && inst.tag !== HostComponent);\n\n      if (inst) {\n        return inst;\n      }\n\n      return null;\n    }\n    /**\n     * Return the lowest common ancestor of A and B, or null if they are in\n     * different trees.\n     */\n\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n\n      var depthB = 0;\n\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      } // If A is deeper, crawl up.\n\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      } // If B is deeper, crawl up.\n\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      } // Walk in lockstep until we find a match.\n\n\n      var depth = depthA;\n\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n\n      return null;\n    }\n    /**\n     * Return if A is an ancestor of B.\n     */\n\n\n    function isAncestor(instA, instB) {\n      while (instB) {\n        if (instA === instB || instA === instB.alternate) {\n          return true;\n        }\n\n        instB = getParent(instB);\n      }\n\n      return false;\n    }\n    /**\n     * Return the parent instance of the passed-in instance.\n     */\n\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n    /**\n     * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n     */\n\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n\n      var i;\n\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], 'captured', arg);\n      }\n\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], 'bubbled', arg);\n      }\n    }\n    /**\n     * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n     * should would receive a `mouseEnter` or `mouseLeave` event.\n     *\n     * Does not invoke the callback on the nearest common ancestor because nothing\n     * \"entered\" or \"left\" that element.\n     */\n\n    /**\n     * Registers plugins so that they can extract and dispatch events.\n     *\n     * @see {EventPluginHub}\n     */\n\n    /**\n     * Ordered list of injected plugins.\n     */\n\n    /**\n     * Mapping from event name to dispatch config\n     */\n\n    /**\n     * Mapping from registration name to plugin module\n     */\n\n    /**\n     * Mapping from registration name to event name\n     */\n\n    /**\n     * Mapping from lowercase registration names to the properly cased version,\n     * used to warn in the case of missing event handlers. Available\n     * only in true.\n     * @type {Object}\n     */\n    // Trust the developer to only use possibleRegistrationNames in true\n\n    /**\n     * Injects an ordering of plugins (by plugin name). This allows the ordering\n     * to be decoupled from injection of the actual plugins so that ordering is\n     * always deterministic regardless of packaging, on-the-fly injection, etc.\n     *\n     * @param {array} InjectedEventPluginOrder\n     * @internal\n     * @see {EventPluginHub.injection.injectEventPluginOrder}\n     */\n\n    /**\n     * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n     * in the ordering injected by `injectEventPluginOrder`.\n     *\n     * Plugins can be injected as part of page initialization or on-the-fly.\n     *\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     * @internal\n     * @see {EventPluginHub.injection.injectEventPluginsByName}\n     */\n\n    /**\n     * Accumulates items that must not be null or undefined into the first one. This\n     * is used to conserve memory by avoiding array allocations, and thus sacrifices\n     * API cleanness. Since `current` can be null before being passed in and not\n     * null after this function, make sure to assign it back to `current`:\n     *\n     * `a = accumulateInto(a, b);`\n     *\n     * This API should be sparingly used. Try `accumulate` for something cleaner.\n     *\n     * @return {*|array<*>} An accumulation of items.\n     */\n\n\n    function accumulateInto(current, next) {\n      if (!(next != null)) {\n        {\n          throw Error(\"accumulateInto(...): Accumulated items must not be null or undefined.\");\n        }\n      }\n\n      if (current == null) {\n        return next;\n      } // Both are not empty. Warning: Never call x.concat(y) when you are not\n      // certain that x is an Array (x could be a string with concat method).\n\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n\n        current.push(next);\n        return current;\n      }\n\n      if (Array.isArray(next)) {\n        // A bit too dangerous to mutate `next`.\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n    /**\n     * @param {array} arr an \"accumulation\" of items which is either an Array or\n     * a single item. Useful when paired with the `accumulate` module. This is a\n     * simple utility that allows us to reason about a collection of items, but\n     * handling the case when there is exactly one item (and we do not need to\n     * allocate an array).\n     * @param {function} cb Callback invoked with each element or a collection.\n     * @param {?} [scope] Scope used as `this` in a callback.\n     */\n\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n\n    function isInteractive(tag) {\n      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n    }\n\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case 'onClick':\n        case 'onClickCapture':\n        case 'onDoubleClick':\n        case 'onDoubleClickCapture':\n        case 'onMouseDown':\n        case 'onMouseDownCapture':\n        case 'onMouseMove':\n        case 'onMouseMoveCapture':\n        case 'onMouseUp':\n        case 'onMouseUpCapture':\n          return !!(props.disabled && isInteractive(type));\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * This is a unified interface for event plugins to be installed and configured.\n     *\n     * Event plugins can implement the following properties:\n     *\n     *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n     *     Required. When a top-level event is fired, this method is expected to\n     *     extract synthetic events that will in turn be queued and dispatched.\n     *\n     *   `eventTypes` {object}\n     *     Optional, plugins that fire events must publish a mapping of registration\n     *     names that are used to register listeners. Values of this mapping must\n     *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n     *\n     *   `executeDispatch` {function(object, function, string)}\n     *     Optional, allows plugins to override how an event gets dispatched. By\n     *     default, the listener is simply invoked.\n     *\n     * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n     *\n     * @public\n     */\n\n    /**\n     * Methods for injecting dependencies.\n     */\n\n    /**\n     * @param {object} inst The instance, which is the source of events.\n     * @param {string} registrationName Name of listener (e.g. `onClick`).\n     * @return {?function} The stored callback.\n     */\n\n\n    function getListener(inst, registrationName) {\n      var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n      // live here; needs to be moved to a better place soon\n\n      var stateNode = inst.stateNode;\n\n      if (!stateNode) {\n        // Work in progress (ex: onload events in incremental mode).\n        return null;\n      }\n\n      var props = getFiberCurrentPropsFromNode$1(stateNode);\n\n      if (!props) {\n        // Work in progress.\n        return null;\n      }\n\n      listener = props[registrationName];\n\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n\n      if (!(!listener || typeof listener === 'function')) {\n        {\n          throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n        }\n      }\n\n      return listener;\n    }\n    /**\n     * Some event types have a notion of different registration names for different\n     * \"phases\" of propagation. This finds listeners by a given phase.\n     */\n\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n    /**\n     * A small set of propagation patterns, each of which will accept a small amount\n     * of information, and generate a set of \"dispatch ready event objects\" - which\n     * are sets of events that have already been annotated with a set of dispatched\n     * listener functions/ids. The API is designed this way to discourage these\n     * propagation strategies from actually executing the dispatches, since we\n     * always want to collect the entire set of dispatches before executing even a\n     * single one.\n     */\n\n    /**\n     * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n     * here, allows us to not have to bind or create functions for each event.\n     * Mutating the event's members allows us to not have to create a wrapping\n     * \"dispatch\" object that pairs the event with the listener.\n     */\n\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n    /**\n     * Collect dispatches (must be entirely collected before dispatching - see unit\n     * tests). Lazily allocate the array to conserve memory.  We must loop through\n     * each event and perform the traversal for each one. We cannot perform a\n     * single traversal for the entire collection of events because each event may\n     * have a different target.\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\n     * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? getParentInstance(targetInst) : null;\n        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\n     * Accumulates without regard to direction, does not look for phased\n     * registration names. Same as `accumulateDirectDispatchesSingle` but without\n     * requiring that the `dispatchMarker` be the same as the dispatched ID.\n     */\n\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n\n        if (listener) {\n          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n        }\n      }\n    }\n    /**\n     * Accumulates dispatches on an `SyntheticEvent`, but only for the\n     * `dispatchMarker`.\n     * @param {SyntheticEvent} event\n     */\n\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n    }\n\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated(events, accumulateDirectDispatchesSingle);\n    }\n    /* eslint valid-typeof: 0 */\n\n\n    var EVENT_POOL_SIZE = 10;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var EventInterface = {\n      type: null,\n      target: null,\n      // currentTarget is set when dispatching; no use in copying it here\n      currentTarget: function () {\n        return null;\n      },\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function (event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n\n    function functionThatReturnsTrue() {\n      return true;\n    }\n\n    function functionThatReturnsFalse() {\n      return false;\n    }\n    /**\n     * Synthetic events are dispatched by event plugins, typically in response to a\n     * top-level event delegation handler.\n     *\n     * These systems should generally use pooling to reduce the frequency of garbage\n     * collection. The system should check `isPersistent` to determine whether the\n     * event should be released into the pool after being dispatched. Users that\n     * need a persisted event should invoke `persist`.\n     *\n     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n     * normalizing browser quirks. Subclasses do not necessarily have to implement a\n     * DOM interface; custom application-specific events can also subclass this.\n     *\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {*} targetInst Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @param {DOMEventTarget} nativeEventTarget Target node.\n     */\n\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        // these have a getter/setter for warnings\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n        delete this.isDefaultPrevented;\n        delete this.isPropagationStopped;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName]; // this has a getter/setter for warnings\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = functionThatReturnsFalse;\n      }\n\n      this.isPropagationStopped = functionThatReturnsFalse;\n      return this;\n    }\n\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function () {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      },\n      stopPropagation: function () {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          // The ChangeEventPlugin registers a \"propertychange\" event for\n          // IE. This event does not support bubbling or cancelling, and\n          // any references to cancelBubble throw \"Member not found\".  A\n          // typeof check of \"unknown\" circumvents this issue (and is also\n          // IE specific).\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = functionThatReturnsTrue;\n      },\n\n      /**\n       * We release all dispatched `SyntheticEvent`s after each event loop, adding\n       * them back into the pool. This allows a way to hold onto a reference that\n       * won't be added back into the pool.\n       */\n      persist: function () {\n        this.isPersistent = functionThatReturnsTrue;\n      },\n\n      /**\n       * Checks if this event should be released back into the pool.\n       *\n       * @return {boolean} True if this should not be released, false otherwise.\n       */\n      isPersistent: functionThatReturnsFalse,\n\n      /**\n       * `PooledClass` looks for `destructor` on each instance it releases.\n       */\n      destructor: function () {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        this.dispatchConfig = null;\n        this._targetInst = null;\n        this.nativeEvent = null;\n        this.isDefaultPrevented = functionThatReturnsFalse;\n        this.isPropagationStopped = functionThatReturnsFalse;\n        this._dispatchListeners = null;\n        this._dispatchInstances = null;\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n          Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n    /**\n     * Helper to reduce boilerplate when creating subclasses.\n     */\n\n    SyntheticEvent.extend = function (Interface) {\n      var Super = this;\n\n      var E = function () {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      function Class() {\n        return Super.apply(this, arguments);\n      }\n\n      _assign(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.extend = Super.extend;\n      addEventPoolingTo(Class);\n      return Class;\n    };\n\n    addEventPoolingTo(SyntheticEvent);\n    /**\n     * Helper to nullify syntheticEvent instance properties when destructing\n     *\n     * @param {String} propName\n     * @param {?object} getVal\n     * @return {object} defineProperty object\n     */\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n\n      if (!(event instanceof EventConstructor)) {\n        {\n          throw Error(\"Trying to release an event instance into a pool of a different type.\");\n        }\n      }\n\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n    /**\n     * `touchHistory` isn't actually on the native event, but putting it in the\n     * interface will ensure that it is cleaned up when pooled/destroyed. The\n     * `ResponderEventPlugin` will populate it appropriately.\n     */\n\n\n    var ResponderSyntheticEvent = SyntheticEvent.extend({\n      touchHistory: function (nativeEvent) {\n        return null; // Actually doesn't even look at the native event.\n      }\n    }); // Note: ideally these would be imported from DOMTopLevelEventTypes,\n    // but our build system currently doesn't let us do that from a fork.\n\n    var TOP_TOUCH_START = 'touchstart';\n    var TOP_TOUCH_MOVE = 'touchmove';\n    var TOP_TOUCH_END = 'touchend';\n    var TOP_TOUCH_CANCEL = 'touchcancel';\n    var TOP_SCROLL = 'scroll';\n    var TOP_SELECTION_CHANGE = 'selectionchange';\n    var TOP_MOUSE_DOWN = 'mousedown';\n    var TOP_MOUSE_MOVE = 'mousemove';\n    var TOP_MOUSE_UP = 'mouseup';\n\n    function isStartish(topLevelType) {\n      return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n    }\n\n    function isMoveish(topLevelType) {\n      return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n    }\n\n    function isEndish(topLevelType) {\n      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n    }\n\n    var startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\n    var moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\n    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n    /**\n     * Tracks the position and time of each active touch by `touch.identifier`. We\n     * should typically only see IDs in the range of 1-20 because IDs get recycled\n     * when touches end and start again.\n     */\n\n    var MAX_TOUCH_BANK = 20;\n    var touchBank = [];\n    var touchHistory = {\n      touchBank: touchBank,\n      numberActiveTouches: 0,\n      // If there is only one active touch, we remember its location. This prevents\n      // us having to loop through all of the touches all the time in the most\n      // common case.\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n\n    function timestampForTouch(touch) {\n      // The legacy internal implementation provides \"timeStamp\", which has been\n      // renamed to \"timestamp\". Let both work for now while we iron it out\n      // TODO (evv): rename timeStamp to timestamp in internal code\n      return touch.timeStamp || touch.timestamp;\n    }\n    /**\n     * TODO: Instead of making gestures recompute filtered velocity, we could\n     * include a built in velocity computation that can be reused globally.\n     */\n\n\n    function createTouchRecord(touch) {\n      return {\n        touchActive: true,\n        startPageX: touch.pageX,\n        startPageY: touch.pageY,\n        startTimeStamp: timestampForTouch(touch),\n        currentPageX: touch.pageX,\n        currentPageY: touch.pageY,\n        currentTimeStamp: timestampForTouch(touch),\n        previousPageX: touch.pageX,\n        previousPageY: touch.pageY,\n        previousTimeStamp: timestampForTouch(touch)\n      };\n    }\n\n    function resetTouchRecord(touchRecord, touch) {\n      touchRecord.touchActive = true;\n      touchRecord.startPageX = touch.pageX;\n      touchRecord.startPageY = touch.pageY;\n      touchRecord.startTimeStamp = timestampForTouch(touch);\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchRecord.previousPageX = touch.pageX;\n      touchRecord.previousPageY = touch.pageY;\n      touchRecord.previousTimeStamp = timestampForTouch(touch);\n    }\n\n    function getTouchIdentifier(_ref) {\n      var identifier = _ref.identifier;\n\n      if (!(identifier != null)) {\n        {\n          throw Error(\"Touch object is missing identifier.\");\n        }\n      }\n\n      {\n        !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK) : void 0;\n      }\n      return identifier;\n    }\n\n    function recordTouchStart(touch) {\n      var identifier = getTouchIdentifier(touch);\n      var touchRecord = touchBank[identifier];\n\n      if (touchRecord) {\n        resetTouchRecord(touchRecord, touch);\n      } else {\n        touchBank[identifier] = createTouchRecord(touch);\n      }\n\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    }\n\n    function recordTouchMove(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = true;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n\n    function recordTouchEnd(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = false;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n\n    function printTouch(touch) {\n      return JSON.stringify({\n        identifier: touch.identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        timestamp: timestampForTouch(touch)\n      });\n    }\n\n    function printTouchBank() {\n      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n      if (touchBank.length > MAX_TOUCH_BANK) {\n        printed += ' (original size: ' + touchBank.length + ')';\n      }\n\n      return printed;\n    }\n\n    var ResponderTouchHistoryStore = {\n      recordTouchTrack: function (topLevelType, nativeEvent) {\n        if (isMoveish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchMove);\n        } else if (isStartish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchStart);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n          }\n        } else if (isEndish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchEnd);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            for (var i = 0; i < touchBank.length; i++) {\n              var touchTrackToCheck = touchBank[i];\n\n              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n                touchHistory.indexOfSingleActiveTouch = i;\n                break;\n              }\n            }\n\n            {\n              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n              !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, 'Cannot find single active touch.') : void 0;\n            }\n          }\n        }\n      },\n      touchHistory: touchHistory\n    };\n    /**\n     * Accumulates items that must not be null or undefined.\n     *\n     * This is used to conserve memory by avoiding array allocations.\n     *\n     * @return {*|array<*>} An accumulation of items.\n     */\n\n    function accumulate(current, next) {\n      if (!(next != null)) {\n        {\n          throw Error(\"accumulate(...): Accumulated items must not be null or undefined.\");\n        }\n      }\n\n      if (current == null) {\n        return next;\n      } // Both are not empty. Warning: Never call x.concat(y) when you are not\n      // certain that x is an Array (x could be a string with concat method).\n\n\n      if (Array.isArray(current)) {\n        return current.concat(next);\n      }\n\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n    /**\n     * Instance of element that should respond to touch/move types of interactions,\n     * as indicated explicitly by relevant callbacks.\n     */\n\n\n    var responderInst = null;\n    /**\n     * Count of current touches. A textInput should become responder iff the\n     * selection changes while there is a touch on the screen.\n     */\n\n    var trackedTouchCount = 0;\n\n    var changeResponder = function (nextResponderInst, blockHostResponder) {\n      var oldResponderInst = responderInst;\n      responderInst = nextResponderInst;\n\n      if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n        ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n      }\n    };\n\n    var eventTypes = {\n      /**\n       * On a `touchStart`/`mouseDown`, is it desired that this element become the\n       * responder?\n       */\n      startShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onStartShouldSetResponder',\n          captured: 'onStartShouldSetResponderCapture'\n        },\n        dependencies: startDependencies\n      },\n\n      /**\n       * On a `scroll`, is it desired that this element become the responder? This\n       * is usually not needed, but should be used to retroactively infer that a\n       * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n       * a touch start will be immediately followed by a scroll event if the view is\n       * currently scrolling.\n       *\n       * TODO: This shouldn't bubble.\n       */\n      scrollShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onScrollShouldSetResponder',\n          captured: 'onScrollShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SCROLL]\n      },\n\n      /**\n       * On text selection change, should this element become the responder? This\n       * is needed for text inputs or other views with native selection, so the\n       * JS view can claim the responder.\n       *\n       * TODO: This shouldn't bubble.\n       */\n      selectionChangeShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onSelectionChangeShouldSetResponder',\n          captured: 'onSelectionChangeShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SELECTION_CHANGE]\n      },\n\n      /**\n       * On a `touchMove`/`mouseMove`, is it desired that this element become the\n       * responder?\n       */\n      moveShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onMoveShouldSetResponder',\n          captured: 'onMoveShouldSetResponderCapture'\n        },\n        dependencies: moveDependencies\n      },\n\n      /**\n       * Direct responder events dispatched directly to responder. Do not bubble.\n       */\n      responderStart: {\n        registrationName: 'onResponderStart',\n        dependencies: startDependencies\n      },\n      responderMove: {\n        registrationName: 'onResponderMove',\n        dependencies: moveDependencies\n      },\n      responderEnd: {\n        registrationName: 'onResponderEnd',\n        dependencies: endDependencies\n      },\n      responderRelease: {\n        registrationName: 'onResponderRelease',\n        dependencies: endDependencies\n      },\n      responderTerminationRequest: {\n        registrationName: 'onResponderTerminationRequest',\n        dependencies: []\n      },\n      responderGrant: {\n        registrationName: 'onResponderGrant',\n        dependencies: []\n      },\n      responderReject: {\n        registrationName: 'onResponderReject',\n        dependencies: []\n      },\n      responderTerminate: {\n        registrationName: 'onResponderTerminate',\n        dependencies: []\n      }\n    };\n    /**\n     *\n     * Responder System:\n     * ----------------\n     *\n     * - A global, solitary \"interaction lock\" on a view.\n     * - If a node becomes the responder, it should convey visual feedback\n     *   immediately to indicate so, either by highlighting or moving accordingly.\n     * - To be the responder means, that touches are exclusively important to that\n     *   responder view, and no other view.\n     * - While touches are still occurring, the responder lock can be transferred to\n     *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n     *   the current responder).\n     *\n     * Responder being granted:\n     * ------------------------\n     *\n     * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n     * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n     *   the \"appropriate place\".\n     * - If nothing is currently the responder, the \"appropriate place\" is the\n     *   initiating event's `targetID`.\n     * - If something *is* already the responder, the \"appropriate place\" is the\n     *   first common ancestor of the event target and the current `responderInst`.\n     * - Some negotiation happens: See the timing diagram below.\n     * - Scrolled views automatically become responder. The reasoning is that a\n     *   platform scroll view that isn't built on top of the responder system has\n     *   began scrolling, and the active responder must now be notified that the\n     *   interaction is no longer locked to it - the system has taken over.\n     *\n     * - Responder being released:\n     *   As soon as no more touches that *started* inside of descendants of the\n     *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n     *   current responder, and the responder lock is released.\n     *\n     * TODO:\n     * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n     *   determines if the responder lock should remain.\n     * - If a view shouldn't \"remain\" the responder, any active touches should by\n     *   default be considered \"dead\" and do not influence future negotiations or\n     *   bubble paths. It should be as if those touches do not exist.\n     * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n     *  after one out of many touches ended. For translate-y, usually the view\n     *  doesn't wish to \"remain\" responder after one of many touches end.\n     * - Consider building this on top of a `stopPropagation` model similar to\n     *   `W3C` events.\n     * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n     *   not `onResponderTerminationRequest` returns `true` or `false`.\n     *\n     */\n\n    /*                                             Negotiation Performed\n                                                 +-----------------------+\n                                                /                         \\\n    Process low level events to    +     Current Responder      +   wantsResponderID\n    determine who to perform negot-|   (if any exists at all)   |\n    iation/transition              | Otherwise just pass through|\n    -------------------------------+----------------------------+------------------+\n    Bubble to find first ID        |                            |\n    to return true:wantsResponderID|                            |\n                                   |                            |\n         +-------------+           |                            |\n         | onTouchStart|           |                            |\n         +------+------+     none  |                            |\n                |            return|                            |\n    +-----------v-------------+true| +------------------------+ |\n    |onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n    +-----------+-------------+    | +------------------------+ |          |\n                |                  |                            | +--------+-------+\n                | returned true for|       false:REJECT +-------->|onResponderReject\n                | wantsResponderID |                    |       | +----------------+\n                | (now attempt     | +------------------+-----+ |\n                |  handoff)        | |   onResponder          | |\n                +------------------->|      TerminationRequest| |\n                                   | +------------------+-----+ |\n                                   |                    |       | +----------------+\n                                   |         true:GRANT +-------->|onResponderGrant|\n                                   |                            | +--------+-------+\n                                   | +------------------------+ |          |\n                                   | |   onResponderTerminate |<-----------+\n                                   | +------------------+-----+ |\n                                   |                    |       | +----------------+\n                                   |                    +-------->|onResponderStart|\n                                   |                            | +----------------+\n    Bubble to find first ID        |                            |\n    to return true:wantsResponderID|                            |\n                                   |                            |\n         +-------------+           |                            |\n         | onTouchMove |           |                            |\n         +------+------+     none  |                            |\n                |            return|                            |\n    +-----------v-------------+true| +------------------------+ |\n    |onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n    +-----------+-------------+    | +------------------------+ |          |\n                |                  |                            | +--------+-------+\n                | returned true for|       false:REJECT +-------->|onResponderRejec|\n                | wantsResponderID |                    |       | +----------------+\n                | (now attempt     | +------------------+-----+ |\n                |  handoff)        | |   onResponder          | |\n                +------------------->|      TerminationRequest| |\n                                   | +------------------+-----+ |\n                                   |                    |       | +----------------+\n                                   |         true:GRANT +-------->|onResponderGrant|\n                                   |                            | +--------+-------+\n                                   | +------------------------+ |          |\n                                   | |   onResponderTerminate |<-----------+\n                                   | +------------------+-----+ |\n                                   |                    |       | +----------------+\n                                   |                    +-------->|onResponderMove |\n                                   |                            | +----------------+\n                                   |                            |\n                                   |                            |\n          Some active touch started|                            |\n          inside current responder | +------------------------+ |\n          +------------------------->|      onResponderEnd    | |\n          |                        | +------------------------+ |\n      +---+---------+              |                            |\n      | onTouchEnd  |              |                            |\n      +---+---------+              |                            |\n          |                        | +------------------------+ |\n          +------------------------->|     onResponderEnd     | |\n          No active touches started| +-----------+------------+ |\n          inside current responder |             |              |\n                                   |             v              |\n                                   | +------------------------+ |\n                                   | |    onResponderRelease  | |\n                                   | +------------------------+ |\n                                   |                            |\n                                   +                            + */\n\n    /**\n     * A note about event ordering in the `EventPluginHub`.\n     *\n     * Suppose plugins are injected in the following order:\n     *\n     * `[R, S, C]`\n     *\n     * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n     * `onClick` etc) and `R` is `ResponderEventPlugin`.\n     *\n     * \"Deferred-Dispatched Events\":\n     *\n     * - The current event plugin system will traverse the list of injected plugins,\n     *   in order, and extract events by collecting the plugin's return value of\n     *   `extractEvents()`.\n     * - These events that are returned from `extractEvents` are \"deferred\n     *   dispatched events\".\n     * - When returned from `extractEvents`, deferred-dispatched events contain an\n     *   \"accumulation\" of deferred dispatches.\n     * - These deferred dispatches are accumulated/collected before they are\n     *   returned, but processed at a later time by the `EventPluginHub` (hence the\n     *   name deferred).\n     *\n     * In the process of returning their deferred-dispatched events, event plugins\n     * themselves can dispatch events on-demand without returning them from\n     * `extractEvents`. Plugins might want to do this, so that they can use event\n     * dispatching as a tool that helps them decide which events should be extracted\n     * in the first place.\n     *\n     * \"On-Demand-Dispatched Events\":\n     *\n     * - On-demand-dispatched events are not returned from `extractEvents`.\n     * - On-demand-dispatched events are dispatched during the process of returning\n     *   the deferred-dispatched events.\n     * - They should not have side effects.\n     * - They should be avoided, and/or eventually be replaced with another\n     *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n     *   extraction.\n     *\n     * Therefore, the sequence of event dispatches becomes:\n     *\n     * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n     * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n     * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n     * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n     * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n     * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n     *\n     * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n     * on-demand dispatch returns `true` (and some other details are satisfied) the\n     * `onResponderGrant` deferred dispatched event is returned from\n     * `extractEvents`. The sequence of dispatch executions in this case\n     * will appear as follows:\n     *\n     * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n     * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n     * - `touchStart`              (`EventPluginHub` dispatches as usual)\n     * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n     */\n\n    function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.\n\n      var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n      // (deepest ID) if it happens to be the current responder. The reasoning:\n      // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n      // the responder.\n\n      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n      var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n      if (skipOverBubbleShouldSetFrom) {\n        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n      } else {\n        accumulateTwoPhaseDispatches(shouldSetEvent);\n      }\n\n      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n      if (!shouldSetEvent.isPersistent()) {\n        shouldSetEvent.constructor.release(shouldSetEvent);\n      }\n\n      if (!wantsResponderInst || wantsResponderInst === responderInst) {\n        return null;\n      }\n\n      var extracted;\n      var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(grantEvent);\n      var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n      if (responderInst) {\n        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n        terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminationRequestEvent);\n        var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n        if (!terminationRequestEvent.isPersistent()) {\n          terminationRequestEvent.constructor.release(terminationRequestEvent);\n        }\n\n        if (shouldSwitch) {\n          var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(terminateEvent);\n          extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n          changeResponder(wantsResponderInst, blockHostResponder);\n        } else {\n          var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(rejectEvent);\n          extracted = accumulate(extracted, rejectEvent);\n        }\n      } else {\n        extracted = accumulate(extracted, grantEvent);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      }\n\n      return extracted;\n    }\n    /**\n     * A transfer is a negotiation between a currently set responder and the next\n     * element to claim responder status. Any start event could trigger a transfer\n     * of responderInst. Any move event could trigger a transfer.\n     *\n     * @param {string} topLevelType Record from `BrowserEventConstants`.\n     * @return {boolean} True if a transfer of responder could possibly occur.\n     */\n\n\n    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n      return topLevelInst && ( // responderIgnoreScroll: We are trying to migrate away from specifically\n      // tracking native scroll events here and responderIgnoreScroll indicates we\n      // will send topTouchCancel to handle canceling touch events instead\n      topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n    }\n    /**\n     * Returns whether or not this touch end event makes it such that there are no\n     * longer any touches that started inside of the current `responderInst`.\n     *\n     * @param {NativeEvent} nativeEvent Native touch end event.\n     * @return {boolean} Whether or not this touch end event ends the responder.\n     */\n\n\n    function noResponderTouches(nativeEvent) {\n      var touches = nativeEvent.touches;\n\n      if (!touches || touches.length === 0) {\n        return true;\n      }\n\n      for (var i = 0; i < touches.length; i++) {\n        var activeTouch = touches[i];\n        var target = activeTouch.target;\n\n        if (target !== null && target !== undefined && target !== 0) {\n          // Is the original touch location inside of the current responder?\n          var targetInst = getInstanceFromNode$1(target);\n\n          if (isAncestor(responderInst, targetInst)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    var ResponderEventPlugin = {\n      /* For unit testing only */\n      _getResponder: function () {\n        return responderInst;\n      },\n      eventTypes: eventTypes,\n\n      /**\n       * We must be resilient to `targetInst` being `null` on `touchMove` or\n       * `touchEnd`. On certain platforms, this means that a native scroll has\n       * assumed control and the original touch targets are destroyed.\n       */\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n        if (isStartish(topLevelType)) {\n          trackedTouchCount += 1;\n        } else if (isEndish(topLevelType)) {\n          if (trackedTouchCount >= 0) {\n            trackedTouchCount -= 1;\n          } else {\n            console.warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n            return null;\n          }\n        }\n\n        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null; // Responder may or may not have transferred on a new touch start/move.\n        // Regardless, whoever is the responder after any potential transfer, we\n        // direct all touch start/move/ends to them in the form of\n        // `onResponderMove/Start/End`. These will be called for *every* additional\n        // finger that move/start/end, dispatched directly to whoever is the\n        // current responder at that moment, until the responder is \"released\".\n        //\n        // These multiple individual change touch events are are always bookended\n        // by `onResponderGrant`, and one of\n        // (`onResponderRelease/onResponderTerminate`).\n\n        var isResponderTouchStart = responderInst && isStartish(topLevelType);\n        var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n        var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n        var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n        if (incrementalTouch) {\n          var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(gesture);\n          extracted = accumulate(extracted, gesture);\n        }\n\n        var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n        var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n        var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n        if (finalTouch) {\n          var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(finalEvent);\n          extracted = accumulate(extracted, finalEvent);\n          changeResponder(null);\n        }\n\n        return extracted;\n      },\n      GlobalResponderHandler: null,\n      injection: {\n        /**\n         * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n         * Object that handles any change in responder. Use this to inject\n         * integration with an existing touch handling system etc.\n         */\n        injectGlobalResponderHandler: function (GlobalResponderHandler) {\n          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n        }\n      }\n    }; // Keep in sync with ReactDOM.js, ReactTestUtils.js, and ReactTestUtilsAct.js:\n\n    var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;\n    var getInstanceFromNode = _ReactDOM$__SECRET_IN[0];\n    var getNodeFromInstance = _ReactDOM$__SECRET_IN[1];\n    var getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2];\n    var injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n    setComponentTree(getFiberCurrentPropsFromNode, getInstanceFromNode, getNodeFromInstance);\n    var ReactDOMUnstableNativeDependencies = Object.freeze({\n      ResponderEventPlugin: ResponderEventPlugin,\n      ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n      injectEventPluginsByName: injectEventPluginsByName\n    });\n    var unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n    module.exports = unstableNativeDependencies;\n  })();\n}","map":{"version":3,"sources":["/Users/brandid.ai/brandidhello/node_modules/react-dom/cjs/react-dom-unstable-native-dependencies.development.js"],"names":["process","env","NODE_ENV","ReactDOM","require","_assign","window","dispatchEvent","document","createEvent","fakeNode","createElement","warningWithoutStack","condition","format","_len","arguments","length","args","Array","_key","undefined","Error","console","argsWithFormat","map","item","unshift","Function","prototype","apply","call","error","argIndex","message","replace","x","warningWithoutStack$1","getFiberCurrentPropsFromNode$1","getInstanceFromNode$1","getNodeFromInstance$1","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","validateEventDispatches","event","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatchesInOrderStopAtTrueImpl","i","isPropagationStopped","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","currentTarget","res","hasDispatches","HostComponent","getParent","inst","return","tag","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","push","accumulateInto","current","next","concat","forEachAccumulated","arr","cb","scope","forEach","isInteractive","shouldPreventMouseEvent","name","type","props","disabled","getListener","registrationName","listener","stateNode","listenerAtPhase","propagationPhase","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","EVENT_POOL_SIZE","EventInterface","target","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","nativeEvent","nativeEventTarget","preventDefault","stopPropagation","isDefaultPrevented","Interface","constructor","propName","hasOwnProperty","normalize","returnValue","cancelBubble","persist","isPersistent","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","getVal","isFunction","configurable","set","get","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","release","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","TOP_MOUSE_DOWN","TOP_MOUSE_MOVE","TOP_MOUSE_UP","isStartish","topLevelType","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes","startShouldSetResponder","bubbled","captured","dependencies","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","extractEvents","eventSystemFlags","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injection","injectGlobalResponderHandler","_ReactDOM$__SECRET_IN","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","Events","getInstanceFromNode","getNodeFromInstance","getFiberCurrentPropsFromNode","injectEventPluginsByName","ReactDOMUnstableNativeDependencies","freeze","unstableNativeDependencies","module","exports"],"mappings":"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","sourcesContent":["/** @license React v16.12.0\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar ReactDOM = require('react-dom');\nvar _assign = require('object-assign');\n\n// Do not require this module directly! Use normal `invariant` calls with\n// template literal strings. The messages will be replaced with error codes\n// during build.\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    \n  }\n}\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n\n    if (condition) {\n      return;\n    }\n\n    if (typeof console !== 'undefined') {\n      var argsWithFormat = args.map(function (item) {\n        return '' + item;\n      });\n      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n      // breaks IE9: https://github.com/facebook/react/issues/13610\n\n      Function.prototype.apply.call(console.error, console, argsWithFormat);\n    }\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar getFiberCurrentPropsFromNode$1 = null;\nvar getInstanceFromNode$1 = null;\nvar getNodeFromInstance$1 = null;\nfunction setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n  getFiberCurrentPropsFromNode$1 = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode$1 = getInstanceFromNodeImpl;\n  getNodeFromInstance$1 = getNodeFromInstanceImpl;\n\n  {\n    !(getNodeFromInstance$1 && getInstanceFromNode$1) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n  }\n}\nvar validateEventDispatches;\n\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\n\n\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\n\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\n\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n\n  {\n    validateEventDispatches(event);\n  }\n\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n\n  return null;\n}\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n\n  if (!!Array.isArray(dispatchListener)) {\n    {\n      throw Error(\"executeDirectDispatch(...): Invalid `event`.\");\n    }\n  }\n\n  event.currentTarget = dispatchListener ? getNodeFromInstance$1(dispatchInstance) : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n// Before we know whether it is function or class\n\n // Root of a host tree. Could be nested inside another node.\n\n // A subtree. Could be an entry point to a different renderer.\n\nvar HostComponent = 5;\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n\n  if (inst) {\n    return inst;\n  }\n\n  return null;\n}\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\n\n\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n\n  var depthB = 0;\n\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  } // If A is deeper, crawl up.\n\n\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  } // If B is deeper, crawl up.\n\n\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  } // Walk in lockstep until we find a match.\n\n\n  var depth = depthA;\n\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n\n  return null;\n}\n/**\n * Return if A is an ancestor of B.\n */\n\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n\n    instB = getParent(instB);\n  }\n\n  return false;\n}\n/**\n * Return the parent instance of the passed-in instance.\n */\n\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\n\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n\n  var i;\n\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\n\n\n\n/**\n * Mapping from event name to dispatch config\n */\n\n\n/**\n * Mapping from registration name to plugin module\n */\n\n\n/**\n * Mapping from registration name to event name\n */\n\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n // Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\n\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  if (!(next != null)) {\n    {\n      throw Error(\"accumulateInto(...): Accumulated items must not be null or undefined.\");\n    }\n  }\n\n  if (current == null) {\n    return next;\n  } // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n\n\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n\n    default:\n      return false;\n  }\n}\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\n\n\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\n\nfunction getListener(inst, registrationName) {\n  var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n\n  var stateNode = inst.stateNode;\n\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n\n  var props = getFiberCurrentPropsFromNode$1(stateNode);\n\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n\n  listener = props[registrationName];\n\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n\n  if (!(!listener || typeof listener === 'function')) {\n    {\n      throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n    }\n  }\n\n  return listener;\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\n\n\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n  }\n\n  var listener = listenerAtPhase(inst, event, phase);\n\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\n\n\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\n\n\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\nvar EVENT_POOL_SIZE = 10;\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\n\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function () {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\n\n\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n  var Interface = this.constructor.Interface;\n\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n\n    var normalize = Interface[propName];\n\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\n\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n\n  _assign(prototype, Class.prototype);\n\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\n\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n\n  if (!(event instanceof EventConstructor)) {\n    {\n      throw Error(\"Trying to release an event instance into a pool of a different type.\");\n    }\n  }\n\n  event.destructor();\n\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\n\nvar ResponderSyntheticEvent = SyntheticEvent.extend({\n  touchHistory: function (nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\n// Note: ideally these would be imported from DOMTopLevelEventTypes,\n// but our build system currently doesn't let us do that from a fork.\nvar TOP_TOUCH_START = 'touchstart';\nvar TOP_TOUCH_MOVE = 'touchmove';\nvar TOP_TOUCH_END = 'touchend';\nvar TOP_TOUCH_CANCEL = 'touchcancel';\nvar TOP_SCROLL = 'scroll';\nvar TOP_SELECTION_CHANGE = 'selectionchange';\nvar TOP_MOUSE_DOWN = 'mousedown';\nvar TOP_MOUSE_MOVE = 'mousemove';\nvar TOP_MOUSE_UP = 'mouseup';\nfunction isStartish(topLevelType) {\n  return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n}\nfunction isMoveish(topLevelType) {\n  return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n}\nfunction isEndish(topLevelType) {\n  return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n}\nvar startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\nvar moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\nvar endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (!(identifier != null)) {\n    {\n      throw Error(\"Touch object is missing identifier.\");\n    }\n  }\n\n  {\n    !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK) : void 0;\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function (topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, 'Cannot find single active touch.') : void 0;\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulate(current, next) {\n  if (!(next != null)) {\n    {\n      throw Error(\"accumulate(...): Accumulated items must not be null or undefined.\");\n    }\n  }\n\n  if (current == null) {\n    return next;\n  } // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n\n\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\n\nvar responderInst = null;\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\n\nvar trackedTouchCount = 0;\n\nvar changeResponder = function (nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onStartShouldSetResponder',\n      captured: 'onStartShouldSetResponderCapture'\n    },\n    dependencies: startDependencies\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onScrollShouldSetResponder',\n      captured: 'onScrollShouldSetResponderCapture'\n    },\n    dependencies: [TOP_SCROLL]\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelectionChangeShouldSetResponder',\n      captured: 'onSelectionChangeShouldSetResponderCapture'\n    },\n    dependencies: [TOP_SELECTION_CHANGE]\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onMoveShouldSetResponder',\n      captured: 'onMoveShouldSetResponderCapture'\n    },\n    dependencies: moveDependencies\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {\n    registrationName: 'onResponderStart',\n    dependencies: startDependencies\n  },\n  responderMove: {\n    registrationName: 'onResponderMove',\n    dependencies: moveDependencies\n  },\n  responderEnd: {\n    registrationName: 'onResponderEnd',\n    dependencies: endDependencies\n  },\n  responderRelease: {\n    registrationName: 'onResponderRelease',\n    dependencies: endDependencies\n  },\n  responderTerminationRequest: {\n    registrationName: 'onResponderTerminationRequest',\n    dependencies: []\n  },\n  responderGrant: {\n    registrationName: 'onResponderGrant',\n    dependencies: []\n  },\n  responderReject: {\n    registrationName: 'onResponderReject',\n    dependencies: []\n  },\n  responderTerminate: {\n    registrationName: 'onResponderTerminate',\n    dependencies: []\n  }\n};\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.\n\n  var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n\n  var extracted;\n  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n\n  return extracted;\n}\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\n\n\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return topLevelInst && ( // responderIgnoreScroll: We are trying to migrate away from specifically\n  // tracking native scroll events here and responderIgnoreScroll indicates we\n  // will send topTouchCancel to handle canceling touch events instead\n  topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n}\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\n\n\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode$1(target);\n\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function () {\n    return responderInst;\n  },\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null; // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n    var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    return extracted;\n  },\n  GlobalResponderHandler: null,\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function (GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    }\n  }\n};\n\n// Keep in sync with ReactDOM.js, ReactTestUtils.js, and ReactTestUtilsAct.js:\n\nvar _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;\nvar getInstanceFromNode = _ReactDOM$__SECRET_IN[0];\nvar getNodeFromInstance = _ReactDOM$__SECRET_IN[1];\nvar getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2];\nvar injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\nsetComponentTree(getFiberCurrentPropsFromNode, getInstanceFromNode, getNodeFromInstance);\n\n\nvar ReactDOMUnstableNativeDependencies = Object.freeze({\n\tResponderEventPlugin: ResponderEventPlugin,\n\tResponderTouchHistoryStore: ResponderTouchHistoryStore,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n\nmodule.exports = unstableNativeDependencies;\n  })();\n}\n"]},"metadata":{},"sourceType":"script"}