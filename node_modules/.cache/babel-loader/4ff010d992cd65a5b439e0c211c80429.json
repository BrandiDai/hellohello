{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport Bridge from './bridge';\nimport { configure } from './configuration';\nimport { MiddlewareChain } from './middleware';\nimport { NativeWrapper } from './wrapper'; // prettier-ignore\n\nexport var Analytics;\n\n(function (Analytics) {\n  var Client =\n  /** @class */\n  function () {\n    function Client() {\n      var _this = this;\n      /**\n       * Whether the client is ready to send events to Segment.\n       *\n       * This becomes `true` when `.setup()` succeeds.\n       * All calls will be queued until it becomes `true`.\n       */\n\n\n      this.ready = false;\n      this.wrapper = new NativeWrapper(this, function (err) {\n        return _this.handleError(err);\n      });\n      this.handlers = [];\n      this.middlewares = new MiddlewareChain(this.wrapper);\n    }\n    /**\n     * Catch React-Native bridge errors\n     *\n     * These errors are emitted when calling the native counterpart.\n     * This only applies to methods with no return value (`Promise<void>`),\n     * methods like `getAnonymousId` do reject promises.\n     */\n\n\n    Client.prototype.catch = function (handler) {\n      this.handlers.push(handler);\n      return this;\n    };\n    /**\n     * Append a new middleware to the middleware chain.\n     *\n     * Middlewares are a powerful mechanism that can augment the events collected by the SDK.\n     * A middleware is a simple function that is invoked by the Segment SDK and can be used to monitor,\n     * modify or reject events.\n     *\n     * Middlewares are invoked for all events, including automatically tracked events,\n     * and external event sources like Adjust and Optimizely.\n     * This offers you the ability the customize those messages to fit your use case even\n     * if the event was sent outside your source code.\n     *\n     * The key thing to observe here is that the output produced by the first middleware feeds into the second.\n     * This allows you to chain and compose independent middlewares!\n     *\n     * For example, you might want to record the device year class with your events.\n     * Previously, you would have to do this everywhere you trigger an event with the Segment SDK.\n     * With middlewares, you can do this in a single place :\n     *\n     * ```js\n     * import DeviceYearClass from 'react-native-device-year-class'\n     *\n     * analytics.middleware(async ({next, context}) =>\n     *   next({\n     *     ...context,\n     *     device_year_class: await DeviceYearClass()\n     *   })\n     * )\n     * ```\n     *\n     * @param middleware\n     */\n\n\n    Client.prototype.middleware = function (middleware) {\n      this.middlewares.add(middleware);\n      return this;\n    };\n    /**\n     * Use the native configuration.\n     *\n     * You'll need to call this method when you configure Analytics's singleton\n     * using the native API.\n     */\n\n\n    Client.prototype.useNativeConfiguration = function () {\n      if (this.ready) {\n        throw new Error('Analytics has already been configured');\n      }\n\n      this.wrapper.ready();\n      return this;\n    };\n    /**\n     * Setup the Analytics module. All calls made before are queued\n     * and only executed if the configuration was successful.\n     *\n     * ```js\n     * await analytics.setup('YOUR_WRITE_KEY', {\n     *   using: [Mixpanel, GoogleAnalytics],\n     *   trackAppLifecycleEvents: true,\n     *   ios: {\n     *     trackDeepLinks: true\n     *   }\n     * })\n     * ```\n     *\n     * @param writeKey Your Segment.io write key\n     * @param configuration An optional {@link Configuration} object.\n     */\n\n\n    Client.prototype.setup = function (writeKey, configuration) {\n      if (configuration === void 0) {\n        configuration = {};\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        var _a, _b;\n\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              _b = (_a = Bridge).setup;\n              return [4\n              /*yield*/\n              , configure(writeKey, configuration)];\n\n            case 1:\n              return [4\n              /*yield*/\n              , _b.apply(_a, [_c.sent()])];\n\n            case 2:\n              _c.sent();\n\n              this.wrapper.ready();\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Record the actions your users perform.\n     *\n     * When a user performs an action in your app, you'll want to track that action for later analysis.\n     * Use the event name to say what the user did, and properties to specify any interesting details of the action.\n     *\n     * @param event The name of the event you're tracking.\n     * We recommend using human-readable names like `Played a Song` or `Updated Status`.\n     * @param properties A dictionary of properties for the event.\n     * If the event was 'Added to Shopping Cart', it might have properties like price, productType, etc.\n     * @param options A dictionary of options, e.g. integrations (thigh analytics integration to forward the event to)\n     */\n\n\n    Client.prototype.track = function (event, properties, options) {\n      if (properties === void 0) {\n        properties = {};\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.middlewares.run('track', {\n                event: event,\n                properties: properties,\n                integrations: options.integrations || {}\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Record the screens or views your users see.\n     *\n     * When a user views a screen in your app, you'll want to record that here.\n     * For some tools like Google Analytics and Flurry, screen views are treated specially, and are different\n     * from \"events\" kind of like \"page views\" on the web. For services that don't treat \"screen views\" specially,\n     * we map \"screen\" straight to \"track\" with the same parameters. For example, Mixpanel doesn't treat \"screen views\" any differently.\n     * So a call to \"screen\" will be tracked as a normal event in Mixpanel, but get sent to Google Analytics and Flurry as a \"screen\".\n     *\n     * @param name The title of the screen being viewed.\n     * We recommend using human-readable names like 'Photo Feed' or 'Completed Purchase Screen'.\n     * @param properties A dictionary of properties for the screen view event.\n     * If the event was 'Added to Shopping Cart', it might have properties like price, productType, etc.\n     */\n\n\n    Client.prototype.screen = function (name, properties, options) {\n      if (properties === void 0) {\n        properties = {};\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.middlewares.run('screen', {\n                name: name,\n                properties: properties,\n                integrations: options.integrations || {}\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Associate a user with their unique ID and record traits about them.\n     *\n     * When you learn more about who your user is, you can record that information with identify.\n     *\n     * @param user database ID (or email address) for this user.\n     * If you don't have a userId but want to record traits, you should pass nil.\n     * For more information on how we generate the UUID and Apple's policies on IDs, see https://segment.io/libraries/ios#ids\n     * @param traits A dictionary of traits you know about the user. Things like: email, name, plan, etc.\n     * @param options A dictionary of options, e.g. integrations (thigh analytics integration to forward the event to)\n     */\n\n\n    Client.prototype.identify = function (user, traits, options) {\n      if (traits === void 0) {\n        traits = {};\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.middlewares.run('identify', {\n                user: user,\n                traits: traits,\n                integrations: options.integrations || {}\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Associate a user with a group, organization, company, project, or w/e *you* call them.\n     *\n     * When you learn more about who the group is, you can record that information with group.\n     *\n     * @param groupId A database ID for this group.\n     * @param traits A dictionary of traits you know about the group. Things like: name, employees, etc.\n     * @param options A dictionary of options, e.g. integrations (thigh analytics integration to forward the event to)\n     */\n\n\n    Client.prototype.group = function (groupId, traits, options) {\n      if (traits === void 0) {\n        traits = {};\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.middlewares.run('group', {\n                groupId: groupId,\n                traits: traits,\n                integrations: options.integrations || {}\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Merge two user identities, effectively connecting two sets of user data as one.\n     * This may not be supported by all integrations.\n     *\n     * When you learn more about who the group is, you can record that information with group.\n     *\n     * @param newId The new ID you want to alias the existing ID to.\n     * The existing ID will be either the previousId if you have called identify, or the anonymous ID.\n     */\n\n\n    Client.prototype.alias = function (newId, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.middlewares.run('alias', {\n                newId: newId,\n                integrations: options.integrations || {}\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Reset any user state that is cached on the device.\n     *\n     * This is useful when a user logs out and you want to clear the identity.\n     * It will clear any traits or userId's cached on the device.\n     */\n\n\n    Client.prototype.reset = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.wrapper.run('reset', function (reset) {\n                return reset();\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Trigger an upload of all queued events.\n     *\n     * This is useful when you want to force all messages queued on the device to be uploaded.\n     * Please note that not all integrations respond to this method.\n     */\n\n\n    Client.prototype.flush = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.wrapper.run('flush', function (flush) {\n                return flush();\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Enable the sending of analytics data. Enabled by default.\n     *\n     * Occasionally used in conjunction with disable user opt-out handling.\n     */\n\n\n    Client.prototype.enable = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.wrapper.run('enable', function (enable) {\n                return enable();\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Completely disable the sending of any analytics data.\n     *\n     * If you have a way for users to actively or passively (sometimes based on location) opt-out of\n     * analytics data collection, you can use this method to turn off all data collection.\n     */\n\n\n    Client.prototype.disable = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.wrapper.run('disable', function (disable) {\n                return disable();\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /** Retrieve the anonymousId. */\n\n\n    Client.prototype.getAnonymousId = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.wrapper.wait()];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              , Bridge.getAnonymousId()];\n          }\n        });\n      });\n    };\n\n    Client.prototype.handleError = function (error) {\n      var handlers = this.handlers;\n\n      if (!handlers.length) {\n        console.error('Uncaught Analytics error', error);\n        throw error;\n      } else {\n        handlers.forEach(function (handler) {\n          return handler(error);\n        });\n      }\n    };\n\n    return Client;\n  }();\n\n  Analytics.Client = Client;\n})(Analytics || (Analytics = {}));","map":{"version":3,"sources":["../../src/analytics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Bridge from './bridge';\nimport { configure } from './configuration';\nimport { MiddlewareChain } from './middleware';\nimport { NativeWrapper } from './wrapper';\n// prettier-ignore\nexport var Analytics;\n(function (Analytics) {\n    var Client = /** @class */ (function () {\n        function Client() {\n            var _this = this;\n            /**\n             * Whether the client is ready to send events to Segment.\n             *\n             * This becomes `true` when `.setup()` succeeds.\n             * All calls will be queued until it becomes `true`.\n             */\n            this.ready = false;\n            this.wrapper = new NativeWrapper(this, function (err) {\n                return _this.handleError(err);\n            });\n            this.handlers = [];\n            this.middlewares = new MiddlewareChain(this.wrapper);\n        }\n        /**\n         * Catch React-Native bridge errors\n         *\n         * These errors are emitted when calling the native counterpart.\n         * This only applies to methods with no return value (`Promise<void>`),\n         * methods like `getAnonymousId` do reject promises.\n         */\n        Client.prototype.catch = function (handler) {\n            this.handlers.push(handler);\n            return this;\n        };\n        /**\n         * Append a new middleware to the middleware chain.\n         *\n         * Middlewares are a powerful mechanism that can augment the events collected by the SDK.\n         * A middleware is a simple function that is invoked by the Segment SDK and can be used to monitor,\n         * modify or reject events.\n         *\n         * Middlewares are invoked for all events, including automatically tracked events,\n         * and external event sources like Adjust and Optimizely.\n         * This offers you the ability the customize those messages to fit your use case even\n         * if the event was sent outside your source code.\n         *\n         * The key thing to observe here is that the output produced by the first middleware feeds into the second.\n         * This allows you to chain and compose independent middlewares!\n         *\n         * For example, you might want to record the device year class with your events.\n         * Previously, you would have to do this everywhere you trigger an event with the Segment SDK.\n         * With middlewares, you can do this in a single place :\n         *\n         * ```js\n         * import DeviceYearClass from 'react-native-device-year-class'\n         *\n         * analytics.middleware(async ({next, context}) =>\n         *   next({\n         *     ...context,\n         *     device_year_class: await DeviceYearClass()\n         *   })\n         * )\n         * ```\n         *\n         * @param middleware\n         */\n        Client.prototype.middleware = function (middleware) {\n            this.middlewares.add(middleware);\n            return this;\n        };\n        /**\n         * Use the native configuration.\n         *\n         * You'll need to call this method when you configure Analytics's singleton\n         * using the native API.\n         */\n        Client.prototype.useNativeConfiguration = function () {\n            if (this.ready) {\n                throw new Error('Analytics has already been configured');\n            }\n            this.wrapper.ready();\n            return this;\n        };\n        /**\n         * Setup the Analytics module. All calls made before are queued\n         * and only executed if the configuration was successful.\n         *\n         * ```js\n         * await analytics.setup('YOUR_WRITE_KEY', {\n         *   using: [Mixpanel, GoogleAnalytics],\n         *   trackAppLifecycleEvents: true,\n         *   ios: {\n         *     trackDeepLinks: true\n         *   }\n         * })\n         * ```\n         *\n         * @param writeKey Your Segment.io write key\n         * @param configuration An optional {@link Configuration} object.\n         */\n        Client.prototype.setup = function (writeKey, configuration) {\n            if (configuration === void 0) { configuration = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var _a, _b;\n                return __generator(this, function (_c) {\n                    switch (_c.label) {\n                        case 0:\n                            _b = (_a = Bridge).setup;\n                            return [4 /*yield*/, configure(writeKey, configuration)];\n                        case 1: return [4 /*yield*/, _b.apply(_a, [_c.sent()])];\n                        case 2:\n                            _c.sent();\n                            this.wrapper.ready();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Record the actions your users perform.\n         *\n         * When a user performs an action in your app, you'll want to track that action for later analysis.\n         * Use the event name to say what the user did, and properties to specify any interesting details of the action.\n         *\n         * @param event The name of the event you're tracking.\n         * We recommend using human-readable names like `Played a Song` or `Updated Status`.\n         * @param properties A dictionary of properties for the event.\n         * If the event was 'Added to Shopping Cart', it might have properties like price, productType, etc.\n         * @param options A dictionary of options, e.g. integrations (thigh analytics integration to forward the event to)\n         */\n        Client.prototype.track = function (event, properties, options) {\n            if (properties === void 0) { properties = {}; }\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.middlewares.run('track', { event: event, properties: properties, integrations: options.integrations || {} })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Record the screens or views your users see.\n         *\n         * When a user views a screen in your app, you'll want to record that here.\n         * For some tools like Google Analytics and Flurry, screen views are treated specially, and are different\n         * from \"events\" kind of like \"page views\" on the web. For services that don't treat \"screen views\" specially,\n         * we map \"screen\" straight to \"track\" with the same parameters. For example, Mixpanel doesn't treat \"screen views\" any differently.\n         * So a call to \"screen\" will be tracked as a normal event in Mixpanel, but get sent to Google Analytics and Flurry as a \"screen\".\n         *\n         * @param name The title of the screen being viewed.\n         * We recommend using human-readable names like 'Photo Feed' or 'Completed Purchase Screen'.\n         * @param properties A dictionary of properties for the screen view event.\n         * If the event was 'Added to Shopping Cart', it might have properties like price, productType, etc.\n         */\n        Client.prototype.screen = function (name, properties, options) {\n            if (properties === void 0) { properties = {}; }\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.middlewares.run('screen', { name: name, properties: properties, integrations: options.integrations || {} })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Associate a user with their unique ID and record traits about them.\n         *\n         * When you learn more about who your user is, you can record that information with identify.\n         *\n         * @param user database ID (or email address) for this user.\n         * If you don't have a userId but want to record traits, you should pass nil.\n         * For more information on how we generate the UUID and Apple's policies on IDs, see https://segment.io/libraries/ios#ids\n         * @param traits A dictionary of traits you know about the user. Things like: email, name, plan, etc.\n         * @param options A dictionary of options, e.g. integrations (thigh analytics integration to forward the event to)\n         */\n        Client.prototype.identify = function (user, traits, options) {\n            if (traits === void 0) { traits = {}; }\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.middlewares.run('identify', { user: user, traits: traits, integrations: options.integrations || {} })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Associate a user with a group, organization, company, project, or w/e *you* call them.\n         *\n         * When you learn more about who the group is, you can record that information with group.\n         *\n         * @param groupId A database ID for this group.\n         * @param traits A dictionary of traits you know about the group. Things like: name, employees, etc.\n         * @param options A dictionary of options, e.g. integrations (thigh analytics integration to forward the event to)\n         */\n        Client.prototype.group = function (groupId, traits, options) {\n            if (traits === void 0) { traits = {}; }\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.middlewares.run('group', { groupId: groupId, traits: traits, integrations: options.integrations || {} })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Merge two user identities, effectively connecting two sets of user data as one.\n         * This may not be supported by all integrations.\n         *\n         * When you learn more about who the group is, you can record that information with group.\n         *\n         * @param newId The new ID you want to alias the existing ID to.\n         * The existing ID will be either the previousId if you have called identify, or the anonymous ID.\n         */\n        Client.prototype.alias = function (newId, options) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.middlewares.run('alias', { newId: newId, integrations: options.integrations || {} })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Reset any user state that is cached on the device.\n         *\n         * This is useful when a user logs out and you want to clear the identity.\n         * It will clear any traits or userId's cached on the device.\n         */\n        Client.prototype.reset = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.wrapper.run('reset', function (reset) { return reset(); })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Trigger an upload of all queued events.\n         *\n         * This is useful when you want to force all messages queued on the device to be uploaded.\n         * Please note that not all integrations respond to this method.\n         */\n        Client.prototype.flush = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.wrapper.run('flush', function (flush) { return flush(); })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Enable the sending of analytics data. Enabled by default.\n         *\n         * Occasionally used in conjunction with disable user opt-out handling.\n         */\n        Client.prototype.enable = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.wrapper.run('enable', function (enable) { return enable(); })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /**\n         * Completely disable the sending of any analytics data.\n         *\n         * If you have a way for users to actively or passively (sometimes based on location) opt-out of\n         * analytics data collection, you can use this method to turn off all data collection.\n         */\n        Client.prototype.disable = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.wrapper.run('disable', function (disable) { return disable(); })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /** Retrieve the anonymousId. */\n        Client.prototype.getAnonymousId = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.wrapper.wait()];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/, Bridge.getAnonymousId()];\n                    }\n                });\n            });\n        };\n        Client.prototype.handleError = function (error) {\n            var handlers = this.handlers;\n            if (!handlers.length) {\n                console.error('Uncaught Analytics error', error);\n                throw error;\n            }\n            else {\n                handlers.forEach(function (handler) { return handler(error); });\n            }\n        };\n        return Client;\n    }());\n    Analytics.Client = Client;\n})(Analytics || (Analytics = {}));\n//# sourceMappingURL=analytics.js.map"]},"metadata":{},"sourceType":"module"}